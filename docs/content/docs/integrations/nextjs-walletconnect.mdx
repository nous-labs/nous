---
title: Next.js + WalletConnect
description: Complete guide to integrating WalletConnect in Next.js applications with the Qubic TypeScript SDK
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Steps } from 'fumadocs-ui/components/steps';

# Next.js + WalletConnect Integration

This guide shows you how to integrate WalletConnect into your Next.js application using the Qubic TypeScript SDK. WalletConnect enables secure wallet connections via QR codes and deep links.

<Callout type="info">
  **Prerequisites**: Get a free WalletConnect Project ID at [WalletConnect Cloud](https://cloud.walletconnect.com/).
</Callout>

## Installation

<Tabs items={['npm', 'yarn', 'bun', 'pnpm']}>
  <Tab value="npm">
    ```bash
    npm install @nvlabs/qts @walletconnect/sign-client @walletconnect/types
    ```
  </Tab>
  <Tab value="yarn">
    ```bash
    yarn add @nvlabs/qts @walletconnect/sign-client @walletconnect/types
    ```
  </Tab>
  <Tab value="bun">
    ```bash
    bun add @nvlabs/qts @walletconnect/sign-client @walletconnect/types
    ```
  </Tab>
  <Tab value="pnpm">
    ```bash
    pnpm add @nvlabs/qts @walletconnect/sign-client @walletconnect/types
    ```
  </Tab>
</Tabs>

## Quick Start

<Steps>

### Add Provider to Layout

The SDK includes a built-in `WalletConnectProvider` - no need to create it manually!

Import and use the provider in `app/layout.tsx`:

```tsx title="app/layout.tsx"
import { WalletConnectProvider } from '@nvlabs/qts/react';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <WalletConnectProvider
          options={{
            projectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!,
            metadata: {
              name: 'My Qubic App',
              description: 'Qubic TypeScript SDK Demo',
              url: 'https://myapp.com',
              icons: ['https://myapp.com/icon.png'],
            },
          }}
        >
          {children}
        </WalletConnectProvider>
      </body>
    </html>
  );
}
```

<Callout type="success">
  **Built-in Provider**: The SDK exports `WalletConnectProvider` and `useWalletConnect` hook with full TypeScript support!
</Callout>

### Create Connect Button Component

Use the hook in your components:

```tsx title="components/connect-button.tsx"
'use client';

import { useState } from 'react';
import { useWalletConnect } from '@nvlabs/qts/react';

export function ConnectButton() {
  const { connect, disconnect, isReady, isConnected, accounts } = useWalletConnect();
  const [uri, setUri] = useState<string>('');
  const [showQR, setShowQR] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);

  const handleConnect = async () => {
    setIsConnecting(true);
    try {
      // Simplified connect - accounts update automatically!
      const { uri, waitForApproval } = await connect();
      
      setUri(uri);
      setShowQR(true);

      // Wait for approval - accounts state updates automatically
      await waitForApproval();
      setShowQR(false);
    } catch (error) {
      console.error('Connection failed:', error);
    } finally {
      setIsConnecting(false);
    }
  };

  const handleDisconnect = async () => {
    await disconnect();
  };

  if (!isReady) {
    return <button disabled>Loading...</button>;
  }

  if (isConnected) {
    return (
      <div>
        <p>Connected: {accounts[0].identity.slice(0, 8)}...</p>
        <button onClick={handleDisconnect}>Disconnect</button>
      </div>
    );
  }

  return (
    <>
      <button onClick={handleConnect} disabled={isConnecting}>
        {isConnecting ? 'Connecting...' : 'Connect Wallet'}
      </button>

      {showQR && uri && (
        <div className="qr-modal">
          <h3>Scan with your wallet</h3>
          <img 
            src={`https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${encodeURIComponent(uri)}`}
            alt="WalletConnect QR Code"
          />
          <button onClick={() => setShowQR(false)}>Cancel</button>
        </div>
      )}
    </>
  );
}
```

<Callout type="success">
  **Automatic Updates**: The provider automatically updates `accounts` and `isConnected` when users approve the connection. No manual state management needed!
</Callout>

</Steps>

## Provider API Reference

The built-in `WalletConnectProvider` exports:

```tsx
interface WalletConnectContextValue {
  adapter: WalletConnectAdapter | null;  // Direct access to adapter
  accounts: WalletAccount[];             // Connected accounts (auto-updates!)
  isConnected: boolean;                  // True if accounts exist
  isReady: boolean;                      // True when adapter initialized
  error: Error | null;                   // Initialization error if any
  connect: () => Promise<{ uri: string; waitForApproval: () => Promise<WalletAccount[]> }>;
  disconnect: () => Promise<void>;       // Disconnect wallet
  refreshAccounts: () => Promise<WalletAccount[]>; // Manually refresh accounts
}
```

### Provider Props

```tsx
<WalletConnectProvider
  options={{
    projectId: string;                   // Required: WalletConnect Project ID
    metadata?: {                         // Optional: App metadata
      name: string;
      description: string;
      url: string;
      icons: string[];
    };
    chainId?: string;                    // Optional: Default 'qubic:mainnet'
    methods?: string[];                  // Optional: Custom RPC methods
    events?: string[];                   // Optional: Custom events
    relayUrl?: string;                   // Optional: Custom relay URL
    storage?: StorageLike;               // Optional: Custom storage
    storageKey?: string;                 // Optional: Custom storage key
  }}
  autoRestoreSession={true}              // Optional: Auto-restore on mount
>
  {children}
</WalletConnectProvider>
```

### Session Restoration

The provider automatically restores existing sessions when `autoRestoreSession={true}` (default):

```tsx
// Session is automatically restored on page reload!
const { accounts, isConnected } = useWalletConnect();

// accounts will be populated if session exists
```

## Signing Transactions

```tsx title="components/send-transaction.tsx"
'use client';

import { useState } from 'react';
import { useWalletConnect } from '@nvlabs/qts/react';
import { createQubicClient } from '@nvlabs/qts';

const qubic = createQubicClient();

export function SendTransaction() {
  const { adapter, accounts, isConnected } = useWalletConnect();
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  const [isSending, setIsSending] = useState(false);

  const handleSend = async () => {
    if (!isConnected || !adapter || !accounts[0]) return;
    if (!adapter || accounts.length === 0) return;

    setIsSending(true);
    try {
      const { tickInfo } = await qubic.live.getTickInfo();

      const transaction = {
        sourceId: accounts[0].identity,
        destId: recipient,
        amount: parseInt(amount),
        tick: tickInfo.tick + 5,
      };

      // adapter.signAndBroadcast is fully typed
      const result = await adapter.signAndBroadcast({
        client: qubic.live,
        transaction,
      });

      alert('Transaction sent! ID: ' + result.transactionId);
    } catch (error) {
      console.error(error);
      alert('Failed to send transaction');
    } finally {
      setIsSending(false);
    }
  };

  return (
    <div>
      <input
        value={recipient}
        onChange={(e) => setRecipient(e.target.value)}
        placeholder="Recipient address"
      />
      <input
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="Amount"
        type="number"
      />
      <button onClick={handleSend} disabled={isSending}>
        {isSending ? 'Sending...' : 'Send'}
      </button>
    </div>
  );
}
```

## Environment Variables

Create `.env.local`:

```bash title=".env.local"
NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=your_project_id_here
```

<Callout type="warn">
  Never commit `.env.local` to version control. Add it to `.gitignore`.
</Callout>

## TypeScript Types

All types are automatically inferred from the SDK:

```tsx
import type {
  WalletConnectAdapter,
  WalletConnectConnection,
  WalletAccount,
  SignTransactionResult,
} from '@nvlabs/qts';

// adapter.connect() returns WalletConnectConnection
const connection: WalletConnectConnection = await adapter.connect();

// connection.uri is string
const qrCodeUri: string = connection.uri;

// connection.approve() returns Promise<WalletAccount[]>
const accounts: WalletAccount[] = await connection.approve();

// Each account has this shape
const account: WalletAccount = {
  identity: 'QUBIC_ADDRESS',
  label?: 'My Wallet',
  publicKey?: '0x...',
  raw?: any,
};
```

## Troubleshooting

### Types Not Showing Up

If you see `const connect: () => Promise<void>` instead of proper types:

**Solution 1**: Return the adapter method directly

```tsx
const connect = useCallback(() => {
  if (!adapter) throw new Error('Not initialized');
  return adapter.connect(); // Returns WalletConnectConnection
}, [adapter]);
```

**Solution 2**: Use explicit return type

```tsx
const connect = useCallback((): ReturnType<WalletConnectAdapter['connect']> => {
  if (!adapter) throw new Error('Not initialized');
  return adapter.connect();
}, [adapter]);
```

### Session Not Persisting

If the wallet disconnects on page reload:

```tsx
useEffect(() => {
  if (adapter?.isConnected) {
    adapter.requestAccounts().then(setAccounts);
  }
}, [adapter]);
```

### Connection Timeout

Increase timeout in adapter initialization:

```tsx
WalletConnectAdapter.init({
  projectId,
  metadata: { /* ... */ },
  // Add custom relay URL or other options if needed
})
```

## Best Practices

### 1. Handle Loading States

```tsx
const { isReady } = useWalletConnect();

if (!isReady) {
  return <div>Initializing WalletConnect...</div>;
}
```

### 2. Error Boundaries

Wrap your app with error boundaries to catch WalletConnect errors.

### 3. Disconnect on Unmount

The adapter handles cleanup automatically, but you can manually disconnect:

```tsx
useEffect(() => {
  return () => {
    // Optional cleanup
  };
}, []);
```

### 4. Check Connection Before Operations

```tsx
const handleSign = async () => {
  if (!adapter || accounts.length === 0) {
    alert('Please connect wallet first');
    return;
  }
  // Continue with signing...
};
```

## Complete Working Example

Here's a complete page component:

```tsx title="app/page.tsx"
'use client';

import { WalletButton } from '@/components/wallet-button';
import { SendTransaction } from '@/components/send-transaction';
import { useWalletConnect } from '@nvlabs/qts/react';

export default function HomePage() {
  const { isConnected, accounts } = useWalletConnect();

  return (
    <div>
      <header>
        <h1>My Qubic App</h1>
        <WalletButton />
      </header>

      <main>
        {isConnected ? (
          <>
            <p>Connected as: {accounts[0].identity}</p>
            <SendTransaction />
          </>
        ) : (
          <p>Please connect your wallet to continue</p>
        )}
      </main>
    </div>
  );
}
```

## React Query Integration

For production apps, combine WalletConnect with React Query for automatic caching, background refetching, and optimistic updates.

### Setup with React Query

Install React Query:

```bash
npm install @tanstack/react-query
```

Add both providers to your layout:

```tsx title="app/layout.tsx"
'use client';

import { QubicQueryProvider, WalletConnectProvider } from '@nvlabs/qts/react';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <QubicQueryProvider>
          <WalletConnectProvider
            options={{
              projectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!,
              metadata: {
                name: 'My Qubic App',
                description: 'Qubic App with React Query',
                url: 'https://myapp.com',
                icons: ['https://myapp.com/icon.png'],
              },
            }}
          >
            {children}
          </WalletConnectProvider>
        </QubicQueryProvider>
      </body>
    </html>
  );
}
```

<Callout type="success">
  **Automatic Integration**: React Query hooks automatically invalidate relevant caches after transactions!
</Callout>

### WalletConnect + React Query Hooks

The SDK provides ready-made hooks that combine WalletConnect with React Query:

```tsx title="components/transaction-form.tsx"
'use client';

import { useState } from 'react';
import { useWalletConnect } from '@nvlabs/qts/react';
import { useWCSignAndBroadcast, useBalance } from '@nvlabs/qts/react/query';

export function TransactionForm() {
  const { accounts, isConnected } = useWalletConnect();
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  
  // Automatically fetches and caches balance
  const { data: balance, isLoading } = useBalance(
    accounts[0]?.identity,
    { enabled: isConnected }
  );
  
  // Mutation with automatic cache invalidation
  const signAndBroadcast = useWCSignAndBroadcast();

  const handleSend = async () => {
    try {
      await signAndBroadcast.mutateAsync({
        from: accounts[0].identity,
        to: recipient,
        amount: amount,
      });
      
      // Balance is automatically refreshed!
      alert('Transaction sent!');
      setRecipient('');
      setAmount('');
    } catch (error) {
      console.error('Failed:', error);
    }
  };

  if (!isConnected) {
    return <p>Connect your wallet first</p>;
  }

  return (
    <div>
      <div>
        <strong>Your Balance:</strong>{' '}
        {isLoading ? 'Loading...' : `${balance?.balance.balance} QUBIC`}
      </div>
      
      <input
        value={recipient}
        onChange={(e) => setRecipient(e.target.value)}
        placeholder="Recipient address"
      />
      
      <input
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="Amount"
        type="number"
      />
      
      <button 
        onClick={handleSend}
        disabled={signAndBroadcast.isPending || !recipient || !amount}
      >
        {signAndBroadcast.isPending ? 'Sending...' : 'Send Transaction'}
      </button>
      
      {signAndBroadcast.isError && (
        <p style={{ color: 'red' }}>Error: {signAndBroadcast.error.message}</p>
      )}
    </div>
  );
}
```

### Available WalletConnect Hooks

All hooks automatically invalidate relevant queries after successful operations:

**Transaction Signing**:
- `useWCSignTransaction()` - Sign transaction (no broadcast)
- `useWCSignAndBroadcast()` - Sign and broadcast transaction
- `useWCSignProcedure()` - Sign smart contract procedure
- `useWCSignAndBroadcastProcedure()` - Sign and broadcast procedure

**Account Management**:
- `useWCRequestAccounts()` - Request/refresh accounts
- `useWCDisconnect()` - Disconnect and clear cache

### Smart Contract Transactions

Execute smart contract procedures with automatic cache management:

```tsx title="components/contract-interaction.tsx"
'use client';

import { useWalletConnect } from '@nvlabs/qts/react';
import { 
  useWCSignAndBroadcastProcedure,
  useCurrentTick 
} from '@nvlabs/qts/react/query';

export function ContractInteraction() {
  const { accounts, isConnected } = useWalletConnect();
  const { data: tickInfo } = useCurrentTick();
  
  const signAndBroadcast = useWCSignAndBroadcastProcedure();

  const handleContractCall = async () => {
    if (!tickInfo) return;
    
    try {
      await signAndBroadcast.mutateAsync({
        call: {
          type: 'contract_call',
          contractIndex: 1,
          inputType: 1,
          inputSize: 32,
        },
        transaction: {
          from: accounts[0].identity,
          to: 'CONTRACT_ADDRESS',
          amount: 0,
          tick: tickInfo.tickInfo.tick + 5,
        },
      });
      
      alert('Contract call successful!');
    } catch (error) {
      console.error('Contract call failed:', error);
    }
  };

  if (!isConnected) {
    return <p>Connect wallet to interact with contracts</p>;
  }

  return (
    <div>
      <h3>Smart Contract Interaction</h3>
      <p>Current Tick: {tickInfo?.tickInfo.tick}</p>
      
      <button 
        onClick={handleContractCall}
        disabled={signAndBroadcast.isPending}
      >
        {signAndBroadcast.isPending ? 'Executing...' : 'Execute Contract Call'}
      </button>
    </div>
  );
}
```

### Real-time Balance Updates

Combine queries and mutations for real-time UI updates:

```tsx title="components/wallet-dashboard.tsx"
'use client';

import { useWalletConnect } from '@nvlabs/qts/react';
import { 
  useBalance,
  useTransactionsForIdentity,
  useCurrentTick 
} from '@nvlabs/qts/react/query';

export function WalletDashboard() {
  const { accounts, isConnected } = useWalletConnect();
  
  // All these queries update automatically!
  const { data: balance } = useBalance(accounts[0]?.identity, {
    enabled: isConnected,
    refetchInterval: 5000, // Refetch every 5 seconds
  });
  
  const { data: transactions } = useTransactionsForIdentity(
    accounts[0]?.identity,
    { pagination: { offset: 0, size: 10 } },
    { enabled: isConnected }
  );
  
  const { data: tick } = useCurrentTick({
    refetchInterval: 1000, // Update every second
  });

  if (!isConnected) {
    return <p>Connect your wallet to view dashboard</p>;
  }

  return (
    <div>
      <h2>Wallet Dashboard</h2>
      
      <div>
        <strong>Balance:</strong> {balance?.balance.balance || 0} QUBIC
      </div>
      
      <div>
        <strong>Current Tick:</strong> {tick?.tickInfo.tick}
      </div>
      
      <h3>Recent Transactions</h3>
      {transactions?.transactions.map((tx, i) => (
        <div key={i}>
          {tx.source} → {tx.destination}: {tx.amount}
        </div>
      ))}
    </div>
  );
}
```

### Optimistic Updates

Show instant feedback before transaction confirmation:

```tsx
import { useWCSignAndBroadcast } from '@nvlabs/qts/react/query';
import { useQueryClient } from '@tanstack/react-query';

export function OptimisticTransfer() {
  const queryClient = useQueryClient();
  const signAndBroadcast = useWCSignAndBroadcast({
    onMutate: async (variables) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['balance', variables.from] });
      
      // Snapshot previous value
      const previousBalance = queryClient.getQueryData(['balance', variables.from]);
      
      // Optimistically update balance
      queryClient.setQueryData(['balance', variables.from], (old: any) => ({
        ...old,
        balance: {
          ...old.balance,
          balance: (old.balance.balance - parseInt(variables.amount)).toString(),
        },
      }));
      
      return { previousBalance };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previousBalance) {
        queryClient.setQueryData(['balance', variables.from], context.previousBalance);
      }
    },
  });
  
  // UI instantly updates, then confirms on-chain
}
```

## Advanced Usage

### Combine with Basic QubicProvider

Use both providers together if you need both React Query and basic client access:

```tsx title="app/layout.tsx"
import { QubicProvider, QubicQueryProvider, WalletConnectProvider } from '@nvlabs/qts/react';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <QubicProvider>
          <QubicQueryProvider>
            <WalletConnectProvider
              options={{
                projectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!,
                metadata: {
                  name: 'My Qubic App',
                  description: 'Qubic App',
                  url: 'https://myapp.com',
                  icons: ['https://myapp.com/icon.png'],
                },
              }}
            >
              {children}
            </WalletConnectProvider>
          </QubicQueryProvider>
        </QubicProvider>
      </body>
    </html>
  );
}
```

Then use all hooks:

```tsx
import { useQubic, useWalletConnect } from '@nvlabs/qts/react';
import { useBalance } from '@nvlabs/qts/react/query';

export function Dashboard() {
  const { live } = useQubic();              // Direct client access
  const { adapter } = useWalletConnect();    // WalletConnect adapter
  const { data: balance } = useBalance('ADDRESS'); // React Query hook
  
  // Access everything!
}
```

### Custom Storage

Use custom storage instead of localStorage:

```tsx
<WalletConnectProvider
  options={{
    projectId: 'YOUR_PROJECT_ID',
    metadata: { /* ... */ },
    storage: window.sessionStorage,  // Use sessionStorage
    storageKey: 'my-app-wc-session', // Custom key
  }}
>
  {children}
</WalletConnectProvider>
```

### Disable Auto-Restore

Disable automatic session restoration:

```tsx
<WalletConnectProvider
  options={{ /* ... */ }}
  autoRestoreSession={false}  // Don't auto-restore
>
  {children}
</WalletConnectProvider>
```

## Complete Example App

Here's a full Next.js page with WalletConnect + React Query:

```tsx title="app/page.tsx"
'use client';

import { useState } from 'react';
import { useWalletConnect } from '@nvlabs/qts/react';
import { 
  useBalance, 
  useCurrentTick,
  useWCSignAndBroadcast 
} from '@nvlabs/qts/react/query';

export default function HomePage() {
  const { connect, disconnect, accounts, isConnected, isReady } = useWalletConnect();
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  const [uri, setUri] = useState('');
  const [showQR, setShowQR] = useState(false);
  
  // React Query hooks
  const { data: balance } = useBalance(accounts[0]?.identity, {
    enabled: isConnected,
    refetchInterval: 5000,
  });
  
  const { data: tick } = useCurrentTick({
    refetchInterval: 1000,
  });
  
  const signAndBroadcast = useWCSignAndBroadcast();
  
  const handleConnect = async () => {
    try {
      const { uri, waitForApproval } = await connect();
      setUri(uri);
      setShowQR(true);
      
      await waitForApproval();
      setShowQR(false);
    } catch (error) {
      console.error(error);
      setShowQR(false);
    }
  };
  
  const handleSend = async () => {
    if (!accounts[0]) return;
    
    try {
      await signAndBroadcast.mutateAsync({
        from: accounts[0].identity,
        to: recipient,
        amount: amount,
      });
      
      alert('Transaction sent!');
      setRecipient('');
      setAmount('');
    } catch (error) {
      console.error('Transaction failed:', error);
    }
  };
  
  if (!isReady) {
    return <div>Loading WalletConnect...</div>;
  }

  return (
    <div style={{ padding: '2rem' }}>
      <header>
        <h1>Qubic Wallet App</h1>
        <p>Current Tick: {tick?.tickInfo.tick || 'Loading...'}</p>
      </header>

      <main>
        {!isConnected ? (
          <div>
            <button onClick={handleConnect}>Connect Wallet</button>
            
            {showQR && uri && (
              <div style={{ marginTop: '1rem' }}>
                <h3>Scan with your wallet:</h3>
                <img 
                  src={`https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${encodeURIComponent(uri)}`}
                  alt="QR Code"
                />
                <button onClick={() => setShowQR(false)}>Cancel</button>
              </div>
            )}
          </div>
        ) : (
          <div>
            <div style={{ marginBottom: '2rem' }}>
              <h2>Wallet Info</h2>
              <p><strong>Address:</strong> {accounts[0].identity.slice(0, 12)}...</p>
              <p><strong>Balance:</strong> {balance?.balance.balance || 0} QUBIC</p>
              <button onClick={disconnect}>Disconnect</button>
            </div>
            
            <div>
              <h2>Send Transaction</h2>
              <input
                value={recipient}
                onChange={(e) => setRecipient(e.target.value)}
                placeholder="Recipient address"
                style={{ width: '100%', marginBottom: '0.5rem', padding: '0.5rem' }}
              />
              <input
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                placeholder="Amount"
                type="number"
                style={{ width: '100%', marginBottom: '0.5rem', padding: '0.5rem' }}
              />
              <button 
                onClick={handleSend}
                disabled={signAndBroadcast.isPending || !recipient || !amount}
                style={{ width: '100%', padding: '0.5rem' }}
              >
                {signAndBroadcast.isPending ? 'Sending...' : 'Send Transaction'}
              </button>
              
              {signAndBroadcast.isError && (
                <p style={{ color: 'red', marginTop: '0.5rem' }}>
                  Error: {signAndBroadcast.error.message}
                </p>
              )}
              
              {signAndBroadcast.isSuccess && (
                <p style={{ color: 'green', marginTop: '0.5rem' }}>
                  Transaction sent successfully!
                </p>
              )}
            </div>
          </div>
        )}
      </main>
    </div>
  );
}
```

## Next Steps

- [React Query Hooks](/docs/integrations/react-query) - Complete React Query reference
- [Smart Contracts](/docs/smart-contracts) - Interact with Qubic contracts
- [Contract Hooks](/docs/integrations/react-query-contracts) - Pre-built contract hooks
- [API Reference](/docs/api-clients) - Explore all client methods

<Callout type="success">
  **Need Help?** Join our [Discord](https://discord.gg/sWX3BakE) or open an issue on [GitHub](https://github.com/nvlabs/qts/issues).
</Callout>

---

*Built with ❤️ using Qubic TypeScript SDK*